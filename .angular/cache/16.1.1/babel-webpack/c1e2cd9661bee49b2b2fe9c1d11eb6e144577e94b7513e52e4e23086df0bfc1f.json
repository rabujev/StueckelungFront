{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { Dto } from '../common/dto';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class FormService {\n  //useBackend: boolean = true; //hopefully same instance injected everywhere    \n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    //this is a Subject (multicastable Observable) others can subscribe to receive its value whenever updated.\n    this.submittedForm = new Subject();\n  }\n  //Fills result Map with the amounts of notes and coins \n  updateTables(total, previousTotal, result, useBackend, difference) {\n    if (useBackend) {\n      this.calcBackend(total, previousTotal, result, difference);\n    } else {\n      this.calcFrontend(total, previousTotal, result, difference);\n      // xc console.log(previousTotal);\n    }\n  }\n  //Gives back result + difference  Maps in an array  from backend \n  calcBackend(total, previousTotal, result, difference) {\n    console.log(\"using backend\");\n    let url = \"http://localhost:5000/api/processFormData\";\n    let dto = new Dto(total, result); // no need to send a difference\n    ;\n    //making post request to backend and setting table data with the response \n    let response = this.httpClient.post(url, dto).subscribe(dto => {\n      //setting result\n      let i = 0;\n      for (let key of result.keys()) {\n        result.set(key, dto.result[i]);\n        i++;\n      }\n      // Setting difference\n      if (previousTotal != null) {\n        i = 0;\n        for (let key of result.keys()) {\n          difference.set(key, dto.difference[i]);\n          i++;\n        }\n      }\n    });\n  }\n  calcFrontend(total, previousTotal, result, difference) {\n    let previousResult = new Map(result); //current Result becomes past result, useful for calculating difference later in this method\n    let rest = total;\n    //for each currency denomination, calculates how many of them fit in the rest amount and fills result map\n    for (let key of result.keys()) {\n      let value = Math.floor(rest / key);\n      result.set(key, value); //should modify result as a side effect \n      rest = rest % key;\n    }\n    //calculating the difference\n    if (previousTotal != null) this.calcFrontDifference(result, previousResult, difference);\n  }\n  calcFrontDifference(result, previousResult, difference) {\n    console.log('dd');\n    for (let key of result.keys()) {\n      let diff = result.get(key) - previousResult.get(key);\n      if (diff > 0) {\n        difference.set(key, '+' + diff);\n      } else if (diff < 0) {\n        difference.set(key, '' + diff);\n      } else if (diff == 0 && previousResult.get(key) != 0) {\n        difference.set(key, ' ' + diff);\n      } else if (diff == 0) {\n        difference.set(key, '' + diff);\n      }\n    }\n  }\n}\nFormService.ɵfac = function FormService_Factory(t) {\n  return new (t || FormService)(i0.ɵɵinject(i1.HttpClient));\n};\nFormService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FormService,\n  factory: FormService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Subject","Dto","FormService","constructor","httpClient","submittedForm","updateTables","total","previousTotal","result","useBackend","difference","calcBackend","calcFrontend","console","log","url","dto","response","post","subscribe","i","key","keys","set","previousResult","Map","rest","value","Math","floor","calcFrontDifference","diff","get","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Jamal-external-drive\\Desktop\\CODE JAMAL\\CurrencyDenominationCalc\\frontend\\src\\app\\services\\form.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { HttpClient } from '@angular/common/http';\nimport { Dto } from '../common/dto';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FormService {\n\n  //this is a Subject (multicastable Observable) others can subscribe to receive its value whenever updated.\n  submittedForm: Subject<[number, boolean]> = new Subject<[number, boolean]>;\n  //useBackend: boolean = true; //hopefully same instance injected everywhere    \n\n  constructor(private httpClient: HttpClient) { }\n\n  //Fills result Map with the amounts of notes and coins \n\n  updateTables(total: number, previousTotal: number | null, result: Map<number, number>,\n    useBackend: boolean,\n    difference: Map<number, string>): void {\n\n    if (useBackend) {\n      this.calcBackend(total, previousTotal, result, difference);\n    } else {\n      this.calcFrontend(total, previousTotal, result, difference);\n\n      // xc console.log(previousTotal);\n    }\n  }\n\n  //Gives back result + difference  Maps in an array  from backend \n\n  calcBackend(total: number, previousTotal: number | null,\n    result: Map<number, number>,\n    difference: Map<number, string>): void \n  {\n\n    console.log(\"using backend\");\n    let url = \"http://localhost:5000/api/processFormData\";\n\n    let dto = new Dto(total, result);   // no need to send a difference\n\n    ;\n    //making post request to backend and setting table data with the response \n    let response = this.httpClient.post<Dto>(url, dto).subscribe(\n      dto => {\n        //setting result\n        let i: number = 0;\n        for (let key of result.keys()) {\n          result.set(key, dto.result[i]);\n          i++;\n        }\n\n        // Setting difference\n        if (previousTotal != null) {\n          i = 0;\n          for (let key of result.keys()) {\n            difference.set(key, dto.difference[i]);\n            i++;\n          }\n        }\n      }\n    );\n\n  }\n\n\n  calcFrontend(total: number, previousTotal: number | null, result: Map<number, number>,\n    difference: Map<number, string>): void  // : Map<any, any>[] lets try no return\n  {\n    let previousResult = new Map(result);   //current Result becomes past result, useful for calculating difference later in this method\n\n\n\n    let rest: number = total;\n    //for each currency denomination, calculates how many of them fit in the rest amount and fills result map\n    for (let key of result.keys()) {\n      let value: number = Math.floor(rest / key);\n      result.set(key, value);  //should modify result as a side effect \n\n      rest = rest % key;\n    }\n    //calculating the difference\n    if (previousTotal != null)\n      this.calcFrontDifference(result, previousResult, difference);\n  }\n\n  calcFrontDifference(result: Map<number, number>,\n    previousResult: Map<number, number>,\n    difference: Map<number, string>): void {\n    console.log('dd')\n    for (let key of result.keys()) {\n\n      let diff: number = result.get(key)! - previousResult.get(key)!;\n\n      if (diff > 0) {\n        difference.set(key, ('+' + diff));\n      } else if (diff < 0) {\n        difference.set(key, ('' + diff));\n      } else if (diff == 0 && previousResult.get(key) != 0) {\n        difference.set(key, (' ' + diff));\n      } else if (diff == 0) {\n        difference.set(key, ('' + diff));\n      }\n\n    }\n\n  }\n\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}