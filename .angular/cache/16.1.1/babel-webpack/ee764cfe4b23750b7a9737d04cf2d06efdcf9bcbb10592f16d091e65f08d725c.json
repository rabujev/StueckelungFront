{"ast":null,"code":"import { Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class FormService {\n  //useBackend: boolean = true; //hopefully same instance injected everywhere    \n  constructor() {\n    //this is a Subject (multicastable Observable) others can subscribe to receive its value whenever updated.\n    this.submittedForm = new Subject();\n  }\n  //Fills result Map with the amounts of notes and coins \n  updateTables(total, previousTotal, result, previousResult, useBackend, difference) {\n    if (useBackend) {\n      this.calcBackend(total, result, previousResult, difference);\n    } else {\n      this.calcFrontend(total, previousTotal, result, previousResult, difference);\n      console.log(previousTotal);\n    }\n  }\n  //Gives back result + difference  Maps in an array  from backend \n  calcBackend(total, result, previousResult, difference) {\n    console.log(\"using backend\");\n    // result = result of call . 0   etc.   so no need for return type \n    // difference = result of call . 1\n  }\n\n  calcFrontend(total, previousTotal, result, previousResult, difference) {\n    previousResult = new Map(result); //current Result becomes past result\n    let rest = total;\n    //for each currency denomination, calculates how many of them fit in the rest amount and fills result map\n    for (let key of result.keys()) {\n      let value = Math.floor(rest / key);\n      result.set(key, value); //should modify result as a side effect \n      rest = rest % key;\n    }\n    //calculating the difference\n    if (previousResult != null) this.calcFrontDifference(result, previousResult, difference);\n  }\n  calcFrontDifference(result, previousResult, difference) {\n    for (let key of result.keys()) {\n      let diff = result.get(key) - previousResult.get(key);\n      if (diff > 0) {\n        difference.set(key, '+' + diff);\n      } else if (diff < 0) {\n        difference.set(key, '-' + diff);\n      } else if (diff == 0) {\n        difference.set(key, '' + diff);\n      }\n    }\n  }\n}\nFormService.ɵfac = function FormService_Factory(t) {\n  return new (t || FormService)();\n};\nFormService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: FormService,\n  factory: FormService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["Subject","FormService","constructor","submittedForm","updateTables","total","previousTotal","result","previousResult","useBackend","difference","calcBackend","calcFrontend","console","log","Map","rest","key","keys","value","Math","floor","set","calcFrontDifference","diff","get","factory","ɵfac","providedIn"],"sources":["C:\\Users\\Jamal-external-drive\\Desktop\\CODE JAMAL\\CurrencyDenominationCalc\\frontend\\src\\app\\services\\form.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FormService {\n\n  //this is a Subject (multicastable Observable) others can subscribe to receive its value whenever updated.\n  submittedForm: Subject<[number, boolean]> = new Subject<[number, boolean]>;\n  //useBackend: boolean = true; //hopefully same instance injected everywhere    \n\n  constructor() { }\n\n  //Fills result Map with the amounts of notes and coins \n\n  updateTables(total: number, previousTotal: number | null, result: Map<number, number>,\n    previousResult: Map<number, number>,\n    useBackend: boolean,\n    difference: Map<number, string>) : void {\n\n      if (useBackend) {\n        this.calcBackend(total, result, previousResult, difference);\n      } else {\n        this.calcFrontend(total, previousTotal, result, previousResult, difference);\n        console.log(previousTotal);\n      }\n  }\n\n  //Gives back result + difference  Maps in an array  from backend \n\n  calcBackend(total: number, result: Map<number, number>,\n    previousResult: Map<number, number>,\n    difference: Map<number, string>): void {\n    console.log(\"using backend\");\n    // result = result of call . 0   etc.   so no need for return type \n    // difference = result of call . 1\n  }\n\n\n  calcFrontend(total: number,previousTotal: number | null, result: Map<number, number>,\n    previousResult: Map<number, number>,\n    difference: Map<number, string>) : void  // : Map<any, any>[] lets try no return\n  {\n    previousResult = new Map(result);   //current Result becomes past result\n\n\n\n    let rest: number = total;\n    //for each currency denomination, calculates how many of them fit in the rest amount and fills result map\n    for (let key of result.keys()) {\n      let value: number = Math.floor(rest / key);\n      result.set(key, value);  //should modify result as a side effect \n\n      rest = rest % key;\n    }\n    //calculating the difference\n    if (previousResult != null)\n      this.calcFrontDifference(result, previousResult, difference);\n\n\n  }\n\n  calcFrontDifference(result: Map<number, number>,\n    previousResult: Map<number, number>,\n    difference: Map<number, string>) : void \n  {\n\n    for (let key of result.keys()) {\n\n      let diff: number = result.get(key)! - previousResult.get(key)!;\n\n      if (diff > 0) {\n        difference.set(key, ('+' + diff));\n      } else if (diff < 0) {\n        difference.set(key, ('-' + diff));\n      } else if (diff == 0) {\n        difference.set(key, ('' + diff));\n      }\n\n    }\n\n  }\n\n\n}\n"],"mappings":"AACA,SAASA,OAAO,QAAQ,MAAM;;AAK9B,OAAM,MAAOC,WAAW;EAItB;EAEAC,YAAA;IAJA;IACA,KAAAC,aAAa,GAA+B,IAAIH,OAA0B,CAA1B,CAA0B;EAG1D;EAEhB;EAEAI,YAAYA,CAACC,KAAa,EAAEC,aAA4B,EAAEC,MAA2B,EACnFC,cAAmC,EACnCC,UAAmB,EACnBC,UAA+B;IAE7B,IAAID,UAAU,EAAE;MACd,IAAI,CAACE,WAAW,CAACN,KAAK,EAAEE,MAAM,EAAEC,cAAc,EAAEE,UAAU,CAAC;KAC5D,MAAM;MACL,IAAI,CAACE,YAAY,CAACP,KAAK,EAAEC,aAAa,EAAEC,MAAM,EAAEC,cAAc,EAAEE,UAAU,CAAC;MAC3EG,OAAO,CAACC,GAAG,CAACR,aAAa,CAAC;;EAEhC;EAEA;EAEAK,WAAWA,CAACN,KAAa,EAAEE,MAA2B,EACpDC,cAAmC,EACnCE,UAA+B;IAC/BG,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;IAC5B;IACA;EACF;;EAGAF,YAAYA,CAACP,KAAa,EAACC,aAA4B,EAAEC,MAA2B,EAClFC,cAAmC,EACnCE,UAA+B;IAE/BF,cAAc,GAAG,IAAIO,GAAG,CAACR,MAAM,CAAC,CAAC,CAAG;IAIpC,IAAIS,IAAI,GAAWX,KAAK;IACxB;IACA,KAAK,IAAIY,GAAG,IAAIV,MAAM,CAACW,IAAI,EAAE,EAAE;MAC7B,IAAIC,KAAK,GAAWC,IAAI,CAACC,KAAK,CAACL,IAAI,GAAGC,GAAG,CAAC;MAC1CV,MAAM,CAACe,GAAG,CAACL,GAAG,EAAEE,KAAK,CAAC,CAAC,CAAE;MAEzBH,IAAI,GAAGA,IAAI,GAAGC,GAAG;;IAEnB;IACA,IAAIT,cAAc,IAAI,IAAI,EACxB,IAAI,CAACe,mBAAmB,CAAChB,MAAM,EAAEC,cAAc,EAAEE,UAAU,CAAC;EAGhE;EAEAa,mBAAmBA,CAAChB,MAA2B,EAC7CC,cAAmC,EACnCE,UAA+B;IAG/B,KAAK,IAAIO,GAAG,IAAIV,MAAM,CAACW,IAAI,EAAE,EAAE;MAE7B,IAAIM,IAAI,GAAWjB,MAAM,CAACkB,GAAG,CAACR,GAAG,CAAE,GAAGT,cAAc,CAACiB,GAAG,CAACR,GAAG,CAAE;MAE9D,IAAIO,IAAI,GAAG,CAAC,EAAE;QACZd,UAAU,CAACY,GAAG,CAACL,GAAG,EAAG,GAAG,GAAGO,IAAK,CAAC;OAClC,MAAM,IAAIA,IAAI,GAAG,CAAC,EAAE;QACnBd,UAAU,CAACY,GAAG,CAACL,GAAG,EAAG,GAAG,GAAGO,IAAK,CAAC;OAClC,MAAM,IAAIA,IAAI,IAAI,CAAC,EAAE;QACpBd,UAAU,CAACY,GAAG,CAACL,GAAG,EAAG,EAAE,GAAGO,IAAK,CAAC;;;EAKtC;;AA5EWvB,WAAW,C;mBAAXA,WAAW;AAAA;AAAXA,WAAW,C;SAAXA,WAAW;EAAAyB,OAAA,EAAXzB,WAAW,CAAA0B,IAAA;EAAAC,UAAA,EAFV;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}