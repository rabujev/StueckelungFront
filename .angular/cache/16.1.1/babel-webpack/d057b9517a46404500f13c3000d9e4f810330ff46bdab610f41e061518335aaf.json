{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { Dto } from '../common/dto';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let FormService = /*#__PURE__*/(() => {\n  class FormService {\n    //useBackend: boolean = true; //hopefully same instance injected everywhere    \n    constructor(httpClient) {\n      this.httpClient = httpClient;\n      //this is a Subject (multicastable Observable) others can subscribe to receive its value whenever updated.\n      this.submittedForm = new Subject();\n    }\n    //Fills result Map with the amounts of notes and coins \n    updateTables(total, previousTotal, result, previousResult, useBackend, difference) {\n      if (useBackend) {\n        this.calcBackend(total, result, previousResult, difference);\n      } else {\n        this.calcFrontend(total, previousTotal, result, previousResult, difference);\n        // xc console.log(previousTotal);\n      }\n    }\n    //Gives back result + difference  Maps in an array  from backend \n    calcBackend(total, result, previousResult, difference) {\n      console.log(\"using backend\");\n      let url = \"http://localhost:5000\";\n      let dto = new Dto(total, result, previousResult, difference);\n      let response = this.httpClient.post(url, dto).subscribe(dto => {\n        result = dto.result;\n        previousResult = dto.previousResult;\n        difference = dto.difference;\n      });\n      // result = result of call . 0   etc.   so no need for return type \n      // difference = result of call . 1\n    }\n\n    calcFrontend(total, previousTotal, result, previousResult, difference) {\n      previousResult = new Map(result); //current Result becomes past result\n      let rest = total;\n      //for each currency denomination, calculates how many of them fit in the rest amount and fills result map\n      for (let key of result.keys()) {\n        let value = Math.floor(rest / key);\n        result.set(key, value); //should modify result as a side effect \n        rest = rest % key;\n      }\n      //calculating the difference\n      if (previousTotal != null) this.calcFrontDifference(result, previousResult, difference);\n    }\n    calcFrontDifference(result, previousResult, difference) {\n      console.log('dd');\n      for (let key of result.keys()) {\n        let diff = result.get(key) - previousResult.get(key);\n        if (diff > 0) {\n          difference.set(key, '+' + diff);\n        } else if (diff < 0) {\n          difference.set(key, '-' + diff);\n        } else if (diff == 0 && previousResult.get(key) != 0) {\n          difference.set(key, ' ' + diff);\n        } else if (diff == 0) {\n          difference.set(key, '' + diff);\n        }\n      }\n    }\n  }\n  FormService.ɵfac = function FormService_Factory(t) {\n    return new (t || FormService)(i0.ɵɵinject(i1.HttpClient));\n  };\n  FormService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FormService,\n    factory: FormService.ɵfac,\n    providedIn: 'root'\n  });\n  return FormService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}